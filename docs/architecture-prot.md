# Amazon Bedrock Novaã‚·ãƒªãƒ¼ã‚ºï¼šæ¬¡ä¸–ä»£AIãƒ¢ãƒ‡ãƒ«ã®ç‰¹å¾´ã¨æ´»ç”¨æ³•

## æ¦‚è¦

Amazon Bedrockã®Novaã‚·ãƒªãƒ¼ã‚ºã¯ã€AWSãŒé–‹ç™ºã—ãŸæœ€æ–°ã®AIãƒ¢ãƒ‡ãƒ«ç¾¤ã§ã€éŸ³å£°å‡¦ç†ã€ãƒãƒ«ãƒãƒ¢ãƒ¼ãƒ€ãƒ«ç†è§£ã€ãã—ã¦åŸ‹ã‚è¾¼ã¿è¡¨ç¾ã«ãŠã„ã¦é©æ–°çš„ãªæ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ã€‚å„ãƒ¢ãƒ‡ãƒ«ã¯ç‰¹å®šã®ç”¨é€”ã«æœ€é©åŒ–ã•ã‚Œã¦ãŠã‚Šã€ä¼æ¥­ã®AIæ´»ç”¨ã‚’å¤§å¹…ã«æ‹¡å¼µã—ã¾ã™ã€‚

## Nova Sonicï¼ˆéŸ³å£°å‡¦ç†ãƒ¢ãƒ‡ãƒ«ï¼‰

### ä¸»è¦ç‰¹å¾´

- **é«˜ç²¾åº¦éŸ³å£°èªè­˜**: è‡ªç„¶ãªä¼šè©±ã‹ã‚‰å°‚é–€ç”¨èªã¾ã§å¹…åºƒã„éŸ³å£°ã‚’æ­£ç¢ºã«èªè­˜
- **å¤šè¨€èªå¯¾å¿œ**: æ—¥æœ¬èªã‚’å«ã‚€è¤‡æ•°è¨€èªã§ã®éŸ³å£°å‡¦ç†ãŒå¯èƒ½
- **ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å‡¦ç†**: ä½ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ã§ã®éŸ³å£°-ãƒ†ã‚­ã‚¹ãƒˆå¤‰æ›
- **ãƒã‚¤ã‚ºè€æ€§**: èƒŒæ™¯éŸ³ãŒã‚ã‚‹ç’°å¢ƒã§ã‚‚é«˜ã„èªè­˜ç²¾åº¦ã‚’ç¶­æŒ

### æŠ€è¡“ä»•æ§˜

- **å…¥åŠ›å½¢å¼**: WAV, MP3, FLACç­‰ã®ä¸»è¦éŸ³å£°ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
- **ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ¬ãƒ¼ãƒˆ**: 8kHzï½48kHzã«å¯¾å¿œ
- **å‡¦ç†é€Ÿåº¦**: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å‡¦ç†ï¼ˆ1å€é€Ÿä»¥ä¸Šï¼‰
- **ç²¾åº¦**: æ¸…éŸ³ç’°å¢ƒã§95%ä»¥ä¸Šã®èªè­˜ç‡

### æ´»ç”¨ã‚·ãƒ¼ãƒ³

- **ã‚³ãƒ¼ãƒ«ã‚»ãƒ³ã‚¿ãƒ¼æ¥­å‹™**: é¡§å®¢å¯¾å¿œã®è‡ªå‹•æ–‡å­—èµ·ã“ã—
- **ä¼šè­°éŒ²ä½œæˆ**: ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒ»ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ä¼šè­°ã®è­°äº‹éŒ²è‡ªå‹•ç”Ÿæˆ
- **éŸ³å£°ã‚³ãƒ³ãƒ†ãƒ³ãƒ„åˆ†æ**: ãƒãƒƒãƒ‰ã‚­ãƒ£ã‚¹ãƒˆã‚„å‹•ç”»ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ãƒ†ã‚­ã‚¹ãƒˆåŒ–
- **ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£**: è´è¦šéšœå®³è€…å‘ã‘ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å­—å¹•ç”Ÿæˆ

## Nova Omniï¼ˆãƒãƒ«ãƒãƒ¢ãƒ¼ãƒ€ãƒ«ãƒ»æ™‚é–“è»¸ç†è§£ãƒ¢ãƒ‡ãƒ«ï¼‰

### ä¸»è¦ç‰¹å¾´

- **çµ±åˆç†è§£èƒ½åŠ›**: ãƒ†ã‚­ã‚¹ãƒˆã€ç”»åƒã€éŸ³å£°ã‚’åŒæ™‚ã«å‡¦ç†ãƒ»ç†è§£
- **æ™‚é–“è»¸ã®æŠŠæ¡**: å‹•ç”»ã‚„é€£ç¶šãƒ‡ãƒ¼ã‚¿ã®æ™‚ç³»åˆ—å¤‰åŒ–ã‚’èªè­˜
- **æ–‡è„ˆä¿æŒ**: é•·æ™‚é–“ã«ã‚ãŸã‚‹æƒ…å ±ã®æ–‡è„ˆã‚’ç¶­æŒ
- **å› æœé–¢ä¿‚æ¨è«–**: æ™‚é–“çµŒéã«ã‚ˆã‚‹å¤‰åŒ–ã®å› æœé–¢ä¿‚ã‚’åˆ†æ

### æŠ€è¡“çš„å„ªä½æ€§

- **ãƒãƒ«ãƒãƒ¢ãƒ¼ãƒ€ãƒ«èåˆ**: ç•°ãªã‚‹ãƒ‡ãƒ¼ã‚¿å½¢å¼é–“ã®ç›¸é–¢é–¢ä¿‚ã‚’ç†è§£
- **ãƒ†ãƒ³ãƒãƒ©ãƒ«åˆ†æ**:
  - å‹•ç”»å†…ã®è¡Œå‹•å¤‰åŒ–ã‚’è¿½è·¡
  - æ™‚ç³»åˆ—ãƒ‡ãƒ¼ã‚¿ã®ãƒ‘ã‚¿ãƒ¼ãƒ³èªè­˜
  - äºˆæ¸¬åˆ†æã®ç²¾åº¦å‘ä¸Š
- **é•·æœŸè¨˜æ†¶**: é•·æ™‚é–“ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã§ã®æƒ…å ±ä¿æŒ

### æ´»ç”¨ã‚·ãƒ¼ãƒ³

- **å‹•ç”»è§£æ**:
  - ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£æ˜ åƒã®ç•°å¸¸æ¤œçŸ¥
  - ã‚¹ãƒãƒ¼ãƒ„æ˜ åƒã®æˆ¦è¡“åˆ†æ
  - è£½é€ ãƒ©ã‚¤ãƒ³ã®å“è³ªç›£è¦–
- **é¡§å®¢è¡Œå‹•åˆ†æ**: Webã‚µã‚¤ãƒˆã§ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼è¡Œå‹•ã®æ™‚ç³»åˆ—è¿½è·¡
- **åŒ»ç™‚è¨ºæ–­æ”¯æ´**: æ¤œæŸ»æ˜ åƒã®æ™‚é–“çµŒéã«ã‚ˆã‚‹å¤‰åŒ–åˆ†æ
- **æ•™è‚²ã‚³ãƒ³ãƒ†ãƒ³ãƒ„**: å­¦ç¿’é€²åº¦ã®å€‹åˆ¥æœ€é©åŒ–

## Nova Multimodal Embeddingsï¼ˆãƒãƒ«ãƒãƒ¢ãƒ¼ãƒ€ãƒ«åŸ‹ã‚è¾¼ã¿ãƒ¢ãƒ‡ãƒ«ï¼‰

### ä¸»è¦ç‰¹å¾´

- **çµ±ä¸€ãƒ™ã‚¯ãƒˆãƒ«ç©ºé–“**: ãƒ†ã‚­ã‚¹ãƒˆã€ç”»åƒã€éŸ³å£°ã‚’åŒä¸€ã®åŸ‹ã‚è¾¼ã¿ç©ºé–“ã«é…ç½®
- **é«˜æ¬¡å…ƒè¡¨ç¾**: è¤‡é›‘ãªæ¦‚å¿µé–¢ä¿‚ã‚’ç²¾å¯†ã«è¡¨ç¾
- **é¡ä¼¼æ€§æ¤œç´¢**: ç•°ãªã‚‹ãƒ¢ãƒ€ãƒªãƒ†ã‚£é–“ã§ã®é¡ä¼¼ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ç™ºè¦‹
- **ã‚¼ãƒ­ã‚·ãƒ§ãƒƒãƒˆåˆ†é¡**: äº‹å‰å­¦ç¿’ãªã—ã§ã®æ–°ã—ã„ã‚«ãƒ†ã‚´ãƒªåˆ†é¡

### æŠ€è¡“ä»•æ§˜

- **ãƒ™ã‚¯ãƒˆãƒ«æ¬¡å…ƒ**: 1024æ¬¡å…ƒã®é«˜ç²¾åº¦åŸ‹ã‚è¾¼ã¿
- **å¯¾å¿œå½¢å¼**:
  - ãƒ†ã‚­ã‚¹ãƒˆ: å¤šè¨€èªå¯¾å¿œ
  - ç”»åƒ: JPEG, PNG, WebP
  - éŸ³å£°: ä¸»è¦éŸ³å£°ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
- **å‡¦ç†æ€§èƒ½**: ãƒãƒƒãƒå‡¦ç†ã§é«˜ã„ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆã‚’å®Ÿç¾

### æ´»ç”¨ã‚·ãƒ¼ãƒ³

- **æ¤œç´¢ã‚·ã‚¹ãƒ†ãƒ **:
  - ç”»åƒã‹ã‚‰é–¢é€£ãƒ†ã‚­ã‚¹ãƒˆã‚’æ¤œç´¢
  - éŸ³å£°ã‚¯ã‚¨ãƒªã«ã‚ˆã‚‹å¤šæ§˜ãªã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ¤œç´¢
- **ã‚³ãƒ³ãƒ†ãƒ³ãƒ„æ¨è–¦**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å¥½ã¿ã‚’å¤šè§’çš„ã«åˆ†æã—ãŸæ¨è–¦
- **é‡è¤‡æ¤œå‡º**: ç•°ãªã‚‹å½¢å¼ã§ã®é¡ä¼¼ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ç™ºè¦‹
- **ãƒ‡ãƒ¼ã‚¿åˆ†é¡**: å¤§é‡ã®éæ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿ã®è‡ªå‹•ã‚«ãƒ†ã‚´ãƒªåˆ†ã‘

## ãƒ¢ãƒ‡ãƒ«é–“ã®é€£æºã¨çµ±åˆæ´»ç”¨

### çµ±åˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

```
å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ï¼ˆéŸ³å£°/ç”»åƒ/ãƒ†ã‚­ã‚¹ãƒˆï¼‰
â†“
Nova Sonicï¼ˆéŸ³å£°å‡¦ç†ï¼‰ + Nova Omniï¼ˆãƒãƒ«ãƒãƒ¢ãƒ¼ãƒ€ãƒ«ç†è§£ï¼‰
â†“
Nova Multimodal Embeddingsï¼ˆçµ±ä¸€è¡¨ç¾ï¼‰
â†“
ä¸‹æµã‚¿ã‚¹ã‚¯ï¼ˆæ¤œç´¢/åˆ†æ/ç”Ÿæˆï¼‰
```

### ã‚·ãƒŠã‚¸ãƒ¼åŠ¹æœ

- **åŒ…æ‹¬çš„ç†è§£**: 3ã¤ã®ãƒ¢ãƒ‡ãƒ«ã®çµ„ã¿åˆã‚ã›ã«ã‚ˆã‚‹æ·±ã„ç†è§£
- **åŠ¹ç‡çš„å‡¦ç†**: å„ãƒ¢ãƒ‡ãƒ«ã®å¾—æ„åˆ†é‡ã‚’æ´»ã‹ã—ãŸæœ€é©åŒ–
- **ã‚¹ã‚±ãƒ¼ãƒ©ãƒ–ãƒ«ãªå±•é–‹**: AWSåŸºç›¤ã§ã®å¤§è¦æ¨¡é‹ç”¨

## å°å…¥æ™‚ã®è€ƒæ…®äº‹é …

### æŠ€è¡“è¦ä»¶

- **APIçµ±åˆ**: RESTful APIã«ã‚ˆã‚‹ç°¡å˜ãªçµ±åˆ
- **ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“**: ç”¨é€”ã«å¿œã˜ãŸé©åˆ‡ãªã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®š
- **ãƒ‡ãƒ¼ã‚¿ãƒ—ãƒ©ã‚¤ãƒã‚·ãƒ¼**: AWSè²¬ä»»å…±æœ‰ãƒ¢ãƒ‡ãƒ«ã§ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ç¢ºä¿

### ã‚³ã‚¹ãƒˆæœ€é©åŒ–

- **ä½¿ç”¨é‡ãƒ™ãƒ¼ã‚¹èª²é‡‘**: å®Ÿéš›ã®ä½¿ç”¨é‡ã«å¿œã˜ãŸæŸ”è»Ÿãªæ–™é‡‘ä½“ç³»
- **ãƒãƒƒãƒå‡¦ç†æ´»ç”¨**: å¤§é‡ãƒ‡ãƒ¼ã‚¿å‡¦ç†æ™‚ã®ã‚³ã‚¹ãƒˆåŠ¹ç‡åŒ–
- **ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥**: é »ç¹ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã®æœ€é©åŒ–

## å®Ÿéš›ã®å°å…¥ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹

### ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹1: ã‚¤ãƒ³ãƒ†ãƒªã‚¸ã‚§ãƒ³ãƒˆãƒ»ã‚«ã‚¹ã‚¿ãƒãƒ¼ã‚µãƒãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ 

**èª²é¡Œ**: å¤§é‡ã®å•ã„åˆã‚ã›ã«å¯¾ã—ã¦ã€å¤šè¨€èªãƒ»ãƒãƒ«ãƒãƒãƒ£ãƒãƒ«ã§ä¸€è²«æ€§ã®ã‚ã‚‹ã‚µãƒãƒ¼ãƒˆã‚’æä¾›

**å®Ÿè£…æ§‹æˆ**:

```
é¡§å®¢æ¥ç‚¹ï¼ˆé›»è©±/ãƒãƒ£ãƒƒãƒˆ/ãƒ¡ãƒ¼ãƒ«/ç”»åƒæ·»ä»˜ï¼‰
â†“
Nova Sonic: éŸ³å£°å•ã„åˆã‚ã›ã®æ–‡å­—èµ·ã“ã—
â†“
Nova Omni: éå»ã®å•ã„åˆã‚ã›å±¥æ­´ã¨ç¾åœ¨ã®æ–‡è„ˆã‚’æ™‚ç³»åˆ—ã§ç†è§£
â†“
Nova Multimodal Embeddings: é¡ä¼¼å•é¡Œã®æ¤œç´¢ãƒ»ãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹å‚ç…§
â†“
Bedrock Agentsï¼ˆStrands Agentsï¼‰: è‡ªå‹•å¿œç­”ãƒ»ã‚¨ã‚¹ã‚«ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³åˆ¤æ–­
```

**å®Ÿè£…ã‚µãƒ³ãƒ—ãƒ« (Python)**:

```python
import boto3
import json

# Bedrock ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåˆæœŸåŒ–
bedrock_runtime = boto3.client('bedrock-runtime', region_name='us-east-1')
bedrock_agent = boto3.client('bedrock-agent-runtime', region_name='us-east-1')

class IntelligentSupportSystem:
    def __init__(self):
        self.conversation_history = []
  
    # Step 1: éŸ³å£°å•ã„åˆã‚ã›ã®å‡¦ç†
    def process_audio_inquiry(self, audio_file_path):
        """Nova Sonicã§éŸ³å£°ã‚’æ–‡å­—èµ·ã“ã—"""
        with open(audio_file_path, 'rb') as audio_file:
            audio_bytes = audio_file.read()
      
        response = bedrock_runtime.invoke_model(
            modelId='amazon.nova-sonic-v1',
            contentType='audio/wav',
            accept='application/json',
            body=audio_bytes
        )
      
        result = json.loads(response['body'].read())
        transcription = result['transcription']
      
        return transcription
  
    # Step 2: ãƒãƒ«ãƒãƒ¢ãƒ¼ãƒ€ãƒ«ç†è§£
    def understand_context(self, text, image_path=None, previous_context=None):
        """Nova Omniã§æ–‡è„ˆã¨ç”»åƒã‚’çµ±åˆç†è§£"""
        request_body = {
            "inputText": text,
            "conversationHistory": previous_context or [],
            "enableTemporalAnalysis": True
        }
      
        if image_path:
            with open(image_path, 'rb') as img_file:
                image_base64 = base64.b64encode(img_file.read()).decode('utf-8')
            request_body["images"] = [image_base64]
      
        response = bedrock_runtime.invoke_model(
            modelId='amazon.nova-omni-v1',
            contentType='application/json',
            accept='application/json',
            body=json.dumps(request_body)
        )
      
        result = json.loads(response['body'].read())
        return result['understanding']
  
    # Step 3: é¡ä¼¼å•é¡Œã®æ¤œç´¢
    def find_similar_cases(self, query_text):
        """Nova Multimodal Embeddingsã§é¡ä¼¼ã‚±ãƒ¼ã‚¹ã‚’æ¤œç´¢"""
        # ã‚¯ã‚¨ãƒªã®ã‚¨ãƒ³ãƒ™ãƒ‡ã‚£ãƒ³ã‚°ç”Ÿæˆ
        embedding_response = bedrock_runtime.invoke_model(
            modelId='amazon.nova-multimodal-embeddings-v1',
            contentType='application/json',
            accept='application/json',
            body=json.dumps({
                "inputText": query_text,
                "embeddingType": "query"
            })
        )
      
        query_embedding = json.loads(embedding_response['body'].read())['embedding']
      
        # ãƒ™ã‚¯ãƒˆãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¤œç´¢ï¼ˆä¾‹: Amazon OpenSearchï¼‰
        similar_cases = self.search_vector_db(query_embedding)
      
        return similar_cases
  
    # Step 4: Agentã«ã‚ˆã‚‹è‡ªå‹•å¯¾å¿œ
    def generate_response_with_agent(self, customer_inquiry, context, similar_cases):
        """Bedrock Agentsã§å¿œç­”ç”Ÿæˆ"""
        response = bedrock_agent.invoke_agent(
            agentId='YOUR_AGENT_ID',
            agentAliasId='YOUR_ALIAS_ID',
            sessionId='unique-session-id',
            inputText=json.dumps({
                "inquiry": customer_inquiry,
                "context": context,
                "similarCases": similar_cases
            })
        )
      
        # ã‚¤ãƒ™ãƒ³ãƒˆã‚¹ãƒˆãƒªãƒ¼ãƒ ã‹ã‚‰å¿œç­”ã‚’å–å¾—
        event_stream = response['completion']
        for event in event_stream:
            if 'chunk' in event:
                chunk = event['chunk']
                if 'bytes' in chunk:
                    agent_response = chunk['bytes'].decode('utf-8')
                    return agent_response
  
    def handle_customer_inquiry(self, audio_path=None, text=None, image_path=None):
        """çµ±åˆå‡¦ç†ãƒ•ãƒ­ãƒ¼"""
        # 1. éŸ³å£°ãŒã‚ã‚‹å ´åˆã¯æ–‡å­—èµ·ã“ã—
        if audio_path:
            text = self.process_audio_inquiry(audio_path)
      
        # 2. ãƒãƒ«ãƒãƒ¢ãƒ¼ãƒ€ãƒ«ç†è§£
        understanding = self.understand_context(
            text, 
            image_path=image_path,
            previous_context=self.conversation_history
        )
      
        # 3. é¡ä¼¼ã‚±ãƒ¼ã‚¹æ¤œç´¢
        similar_cases = self.find_similar_cases(text)
      
        # 4. Agentå¿œç­”ç”Ÿæˆ
        response = self.generate_response_with_agent(
            customer_inquiry=text,
            context=understanding,
            similar_cases=similar_cases
        )
      
        # å±¥æ­´ã«è¿½åŠ 
        self.conversation_history.append({
            "inquiry": text,
            "response": response,
            "timestamp": datetime.now().isoformat()
        })
      
        return response

# ä½¿ç”¨ä¾‹
support_system = IntelligentSupportSystem()
response = support_system.handle_customer_inquiry(
    audio_path="customer_call.wav",
    image_path="product_issue.jpg"
)
print(response)
```

**æœŸå¾…ã•ã‚Œã‚‹åŠ¹æœ**:

- å¿œç­”æ™‚é–“ã®70%å‰Šæ¸›
- å¤šè¨€èªå¯¾å¿œã«ã‚ˆã‚‹å›½éš›å±•é–‹ã®åŠ é€Ÿ
- é¡§å®¢æº€è¶³åº¦ã®å‘ä¸Šï¼ˆä¸€è²«æ€§ã®ã‚ã‚‹å¯¾å¿œï¼‰

### ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹2: è£½é€ æ¥­ã®å“è³ªç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

**èª²é¡Œ**: è£½é€ ãƒ©ã‚¤ãƒ³ã§ã®ä¸è‰¯å“æ¤œçŸ¥ã¨åŸå› åˆ†æã®è‡ªå‹•åŒ–

**å®Ÿè£…æ§‹æˆ**:

```
è£½é€ ãƒ©ã‚¤ãƒ³ï¼ˆã‚«ãƒ¡ãƒ©/ã‚»ãƒ³ã‚µãƒ¼/éŸ³å£°ï¼‰
â†“
Nova Omni: è£½å“ã®æ™‚ç³»åˆ—æ˜ åƒåˆ†æ + æ©Ÿæ¢°éŸ³ã®ç•°å¸¸æ¤œçŸ¥
â†“
Nova Multimodal Embeddings: éå»ã®ä¸è‰¯ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ã®é¡ä¼¼æ€§æ¯”è¼ƒ
â†“
Agent Core: åŸå› åˆ†æãƒ»å¯¾å¿œæ‰‹é †ã®æç¤ºãƒ»ã‚¢ãƒ©ãƒ¼ãƒˆé€ä¿¡
```

**å®Ÿè£…ã‚µãƒ³ãƒ—ãƒ« (Python)**:

```python
import boto3
import json
from datetime import datetime, timedelta

class QualityControlSystem:
    def __init__(self, agent_id, knowledge_base_id):
        self.bedrock_runtime = boto3.client('bedrock-runtime')
        self.bedrock_agent = boto3.client('bedrock-agent-runtime')
        self.agent_id = agent_id
        self.knowledge_base_id = knowledge_base_id
      
    def analyze_production_line(self, video_stream, audio_stream, duration=60):
        """è£½é€ ãƒ©ã‚¤ãƒ³ã®æ˜ åƒã¨éŸ³å£°ã‚’ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åˆ†æ"""
        analysis_results = []
      
        # Nova Omniã§ãƒ“ãƒ‡ã‚ªã‚¹ãƒˆãƒªãƒ¼ãƒ åˆ†æ
        for timestamp in range(0, duration, 5):  # 5ç§’é–“éš”
            frame_data = video_stream.get_frame(timestamp)
            audio_data = audio_stream.get_segment(timestamp, timestamp + 5)
          
            # ãƒãƒ«ãƒãƒ¢ãƒ¼ãƒ€ãƒ«åˆ†æ
            analysis = self.bedrock_runtime.invoke_model(
                modelId='amazon.nova-omni-v1',
                contentType='application/json',
                accept='application/json',
                body=json.dumps({
                    "video": frame_data,
                    "audio": audio_data,
                    "analysisType": "temporal-anomaly-detection",
                    "timeWindow": 30  # éå»30ç§’ã®æ–‡è„ˆã‚’è€ƒæ…®
                })
            )
          
            result = json.loads(analysis['body'].read())
            if result.get('anomalyDetected'):
                analysis_results.append({
                    "timestamp": timestamp,
                    "anomaly": result['anomalyDetails'],
                    "confidence": result['confidence']
                })
      
        return analysis_results
  
    def find_similar_defects(self, anomaly_data):
        """éå»ã®ä¸è‰¯äº‹ä¾‹ã‹ã‚‰é¡ä¼¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œç´¢"""
        # ã‚¨ãƒ³ãƒ™ãƒ‡ã‚£ãƒ³ã‚°ç”Ÿæˆ
        embedding_response = self.bedrock_runtime.invoke_model(
            modelId='amazon.nova-multimodal-embeddings-v1',
            contentType='application/json',
            body=json.dumps({
                "multimodalInput": {
                    "image": anomaly_data['visual_features'],
                    "audio": anomaly_data['audio_features'],
                    "text": anomaly_data['description']
                }
            })
        )
      
        embedding = json.loads(embedding_response['body'].read())['embedding']
      
        # ãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹æ¤œç´¢
        search_response = self.bedrock_agent.retrieve(
            knowledgeBaseId=self.knowledge_base_id,
            retrievalQuery={
                "embedding": embedding,
                "numberOfResults": 5
            }
        )
      
        return search_response['retrievalResults']
  
    def diagnose_and_recommend(self, anomaly_data, similar_defects):
        """Agent Coreã§åŸå› è¨ºæ–­ã¨å¯¾å¿œæ¨å¥¨"""
      
        # Agentå‘¼ã³å‡ºã—
        response = self.bedrock_agent.invoke_agent(
            agentId=self.agent_id,
            agentAliasId='PROD',
            sessionId=f"qc-{datetime.now().strftime('%Y%m%d-%H%M%S')}",
            inputText=json.dumps({
                "task": "diagnose_defect",
                "currentAnomaly": anomaly_data,
                "historicalSimilarCases": similar_defects,
                "productionContext": {
                    "line": "A-3",
                    "product": "Widget-X200",
                    "shift": "morning"
                }
            }),
            # Agentã«ãƒ„ãƒ¼ãƒ«ä½¿ç”¨ã‚’è¨±å¯
            enableTrace=True
        )
      
        # è¨ºæ–­çµæœã®å–å¾—
        diagnosis = {
            "rootCause": None,
            "recommendations": [],
            "urgency": "medium"
        }
      
        for event in response['completion']:
            if 'chunk' in event:
                chunk_data = json.loads(event['chunk']['bytes'].decode('utf-8'))
                if 'diagnosis' in chunk_data:
                    diagnosis = chunk_data['diagnosis']
      
        return diagnosis
  
    def execute_quality_control(self, video_stream, audio_stream):
        """å“è³ªç®¡ç†ã®å®Œå…¨ãƒ•ãƒ­ãƒ¼"""
        # 1. è£½é€ ãƒ©ã‚¤ãƒ³åˆ†æ
        print("ğŸ” è£½é€ ãƒ©ã‚¤ãƒ³ã‚’åˆ†æä¸­...")
        anomalies = self.analyze_production_line(video_stream, audio_stream)
      
        if not anomalies:
            return {"status": "normal", "message": "ç•°å¸¸ã¯æ¤œå‡ºã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ"}
      
        # 2. å„ç•°å¸¸ã«ã¤ã„ã¦å‡¦ç†
        results = []
        for anomaly in anomalies:
            print(f"âš ï¸ ç•°å¸¸æ¤œçŸ¥: {anomaly['timestamp']}ç§’æ™‚ç‚¹")
          
            # é¡ä¼¼ä¸è‰¯äº‹ä¾‹æ¤œç´¢
            similar_defects = self.find_similar_defects(anomaly['anomaly'])
          
            # è¨ºæ–­ã¨æ¨å¥¨
            diagnosis = self.diagnose_and_recommend(
                anomaly['anomaly'], 
                similar_defects
            )
          
            results.append({
                "timestamp": anomaly['timestamp'],
                "diagnosis": diagnosis,
                "action_required": diagnosis['urgency'] in ['high', 'critical']
            })
          
            # ç·Šæ€¥åº¦ãŒé«˜ã„å ´åˆã¯å³åº§ã«ã‚¢ãƒ©ãƒ¼ãƒˆ
            if diagnosis['urgency'] in ['high', 'critical']:
                self.send_alert(diagnosis)
      
        return {
            "status": "anomalies_detected",
            "total_anomalies": len(anomalies),
            "results": results
        }
  
    def send_alert(self, diagnosis):
        """ã‚¢ãƒ©ãƒ¼ãƒˆé€ä¿¡ï¼ˆSNSç­‰ï¼‰"""
        sns = boto3.client('sns')
        sns.publish(
            TopicArn='arn:aws:sns:region:account:quality-alerts',
            Subject='ğŸš¨ è£½é€ ãƒ©ã‚¤ãƒ³ç•°å¸¸æ¤œçŸ¥',
            Message=json.dumps(diagnosis, ensure_ascii=False, indent=2)
        )

# ä½¿ç”¨ä¾‹
qc_system = QualityControlSystem(
    agent_id='YOUR_AGENT_ID',
    knowledge_base_id='YOUR_KB_ID'
)

# ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–
video_stream = ProductionLineCamera(line='A-3')
audio_stream = MachineAudioSensor(line='A-3')

results = qc_system.execute_quality_control(video_stream, audio_stream)
print(json.dumps(results, ensure_ascii=False, indent=2))
```

**æœŸå¾…ã•ã‚Œã‚‹åŠ¹æœ**:

- ä¸è‰¯å“æ¤œå‡ºç‡ã®99%ä»¥ä¸Šé”æˆ
- æ¤œæŸ»æ™‚é–“ã®80%å‰Šæ¸›
- åŸå› ç‰¹å®šæ™‚é–“ã®90%çŸ­ç¸®

## Bedrock Agentsï¼ˆStrands Agents / Agent Coreï¼‰ã¨ã®çµ±åˆãƒ‘ã‚¿ãƒ¼ãƒ³

### çµ±åˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Application Layer                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Bedrock Agent (Orchestration)                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚ Action      â”‚  â”‚ Knowledge    â”‚  â”‚ Guardrails   â”‚       â”‚
â”‚  â”‚ Groups      â”‚  â”‚ Base         â”‚  â”‚              â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Nova Models Layer                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚  Sonic   â”‚  â”‚  Omni    â”‚  â”‚  Multimodal         â”‚       â”‚
â”‚  â”‚ (Speech) â”‚  â”‚ (Vision) â”‚  â”‚  Embeddings         â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ãƒ‘ã‚¿ãƒ¼ãƒ³1: Agentä¸»å°å‹ï¼ˆAgentãŒå„Novaãƒ¢ãƒ‡ãƒ«ã‚’å‘¼ã³å‡ºã—ï¼‰

**ç‰¹å¾´**: AgentãŒã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼ã¨ã—ã¦æ©Ÿèƒ½ã—ã€å¿…è¦ã«å¿œã˜ã¦Novaãƒ¢ãƒ‡ãƒ«ã‚’æ´»ç”¨

**å®Ÿè£…ä¾‹**:

```python
# Agentå®šç¾©ï¼ˆCloudFormation/CDKï¼‰
agent_config = {
    "agentName": "MultimodalAnalysisAgent",
    "foundation_model": "anthropic.claude-v3-sonnet",
    "instruction": """
    ã‚ãªãŸã¯è¤‡æ•°ã®AIãƒ¢ãƒ‡ãƒ«ã‚’æ´»ç”¨ã™ã‚‹ãƒãƒ«ãƒãƒ¢ãƒ¼ãƒ€ãƒ«åˆ†æã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§ã™ã€‚
    ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è¦æ±‚ã«å¿œã˜ã¦ä»¥ä¸‹ã®ãƒ„ãƒ¼ãƒ«ã‚’é©åˆ‡ã«ä½¿ç”¨ã—ã¦ãã ã•ã„ï¼š
  
    1. process_audio: éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ–‡å­—èµ·ã“ã—ï¼ˆNova Sonicä½¿ç”¨ï¼‰
    2. analyze_video: å‹•ç”»ã®æ™‚ç³»åˆ—åˆ†æï¼ˆNova Omniä½¿ç”¨ï¼‰
    3. search_similar: ãƒãƒ«ãƒãƒ¢ãƒ¼ãƒ€ãƒ«æ¤œç´¢ï¼ˆNova Embeddingsä½¿ç”¨ï¼‰
    4. query_knowledge: ãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹ã‹ã‚‰æƒ…å ±å–å¾—
    """,
    "actionGroups": [
        {
            "actionGroupName": "NovaToolsGroup",
            "actionGroupExecutor": {
                "lambda": "arn:aws:lambda:region:account:function:nova-tools"
            },
            "apiSchema": {
                "payload": json.dumps({
                    "openapi": "3.0.0",
                    "paths": {
                        "/process-audio": {
                            "post": {
                                "description": "éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›",
                                "parameters": [
                                    {
                                        "name": "audioUrl",
                                        "in": "query",
                                        "required": True,
                                        "schema": {"type": "string"}
                                    }
                                ]
                            }
                        },
                        "/analyze-video": {
                            "post": {
                                "description": "å‹•ç”»ã®æ™‚ç³»åˆ—åˆ†æã‚’å®Ÿè¡Œ",
                                "parameters": [
                                    {
                                        "name": "videoUrl",
                                        "in": "query",
                                        "required": True
                                    },
                                    {
                                        "name": "analysisType",
                                        "in": "query",
                                        "schema": {
                                            "type": "string",
                                            "enum": ["anomaly", "action", "quality"]
                                        }
                                    }
                                ]
                            }
                        },
                        "/search-similar": {
                            "post": {
                                "description": "ãƒãƒ«ãƒãƒ¢ãƒ¼ãƒ€ãƒ«é¡ä¼¼æ¤œç´¢",
                                "requestBody": {
                                    "content": {
                                        "application/json": {
                                            "schema": {
                                                "type": "object",
                                                "properties": {
                                                    "text": {"type": "string"},
                                                    "imageUrl": {"type": "string"},
                                                    "audioUrl": {"type": "string"}
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                })
            }
        }
    ],
    "knowledgeBases": [
        {
            "knowledgeBaseId": "YOUR_KB_ID",
            "description": "ä¼æ¥­ãƒŠãƒ¬ãƒƒã‚¸ãƒ™ãƒ¼ã‚¹"
        }
    ]
}

# Lambdaé–¢æ•°ï¼ˆAgent Actionå®Ÿè£…ï¼‰
def lambda_handler(event, context):
    """Agentã‹ã‚‰ã®Actionå‘¼ã³å‡ºã—ã‚’å‡¦ç†"""
    bedrock = boto3.client('bedrock-runtime')
  
    action = event['actionGroup']
    api_path = event['apiPath']
    parameters = event.get('parameters', [])
  
    if api_path == '/process-audio':
        audio_url = get_parameter(parameters, 'audioUrl')
      
        # Nova Sonicå‘¼ã³å‡ºã—
        audio_data = download_file(audio_url)
        response = bedrock.invoke_model(
            modelId='amazon.nova-sonic-v1',
            body=audio_data
        )
      
        transcription = json.loads(response['body'].read())['transcription']
      
        return {
            'actionGroup': action,
            'apiPath': api_path,
            'httpStatusCode': 200,
            'responseBody': {
                'application/json': {
                    'body': json.dumps({
                        "transcription": transcription,
                        "success": True
                    })
                }
            }
        }
  
    elif api_path == '/analyze-video':
        video_url = get_parameter(parameters, 'videoUrl')
        analysis_type = get_parameter(parameters, 'analysisType')
      
        # Nova Omniå‘¼ã³å‡ºã—
        video_data = download_file(video_url)
        response = bedrock.invoke_model(
            modelId='amazon.nova-omni-v1',
            body=json.dumps({
                "video": video_data,
                "analysisType": analysis_type,
                "enableTemporalAnalysis": True
            })
        )
      
        analysis_result = json.loads(response['body'].read())
      
        return {
            'actionGroup': action,
            'apiPath': api_path,
            'httpStatusCode': 200,
            'responseBody': {
                'application/json': {
                    'body': json.dumps(analysis_result)
                }
            }
        }
  
    elif api_path == '/search-similar':
        request_body = json.loads(event['requestBody']['content']['application/json']['body'])
      
        # Nova Multimodal Embeddingså‘¼ã³å‡ºã—
        response = bedrock.invoke_model(
            modelId='amazon.nova-multimodal-embeddings-v1',
            body=json.dumps(request_body)
        )
      
        embedding = json.loads(response['body'].read())['embedding']
      
        # ãƒ™ã‚¯ãƒˆãƒ«æ¤œç´¢å®Ÿè¡Œ
        search_results = perform_vector_search(embedding)
      
        return {
            'actionGroup': action,
            'apiPath': api_path,
            'httpStatusCode': 200,
            'responseBody': {
                'application/json': {
                    'body': json.dumps({
                        "results": search_results,
                        "count": len(search_results)
                    })
                }
            }
        }

# Agentä½¿ç”¨ä¾‹
def use_multimodal_agent():
    bedrock_agent = boto3.client('bedrock-agent-runtime')
  
    # ä¼šè­°éŒ²ã®è‡ªå‹•ç”Ÿæˆ
    response = bedrock_agent.invoke_agent(
        agentId='YOUR_AGENT_ID',
        agentAliasId='PROD',
        sessionId='meeting-001',
        inputText="""
        ä»¥ä¸‹ã®ä¼šè­°éŒ²éŸ³ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‡¦ç†ã—ã¦ãã ã•ã„ï¼š
        s3://meetings/2024-01-15-strategy-meeting.mp3
      
        ã‚¿ã‚¹ã‚¯ï¼š
        1. éŸ³å£°ã‚’æ–‡å­—èµ·ã“ã—
        2. ä¸»è¦ãªãƒˆãƒ”ãƒƒã‚¯ã‚’æŠ½å‡º
        3. éå»ã®é¡ä¼¼ä¼šè­°ã‚’æ¤œç´¢
        4. ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã¾ã¨ã‚ã‚‹
        """
    )
  
    # å¿œç­”ã®ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å‡¦ç†
    for event in response['completion']:
        if 'chunk' in event:
            print(event['chunk']['bytes'].decode('utf-8'))
```

### ãƒ‘ã‚¿ãƒ¼ãƒ³2: ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å‹ï¼ˆå‰å‡¦ç†ã«Novaã€æ¨è«–ã«Agentï¼‰

**ç‰¹å¾´**: Novaãƒ¢ãƒ‡ãƒ«ã§ãƒ‡ãƒ¼ã‚¿ã‚’å‰å‡¦ç†ã—ã€ãã®çµæœã‚’Agentã«æ¸¡ã—ã¦é«˜åº¦ãªæ¨è«–

**å®Ÿè£…ä¾‹**:

```python
class MultimodalPipeline:
    def __init__(self, agent_id):
        self.bedrock = boto3.client('bedrock-runtime')
        self.bedrock_agent = boto3.client('bedrock-agent-runtime')
        self.agent_id = agent_id
  
    def preprocess_multimodal_data(self, data_sources):
        """Nova modelsã§ãƒ‡ãƒ¼ã‚¿ã‚’å‰å‡¦ç†"""
        processed_data = {}
      
        # éŸ³å£°ãƒ‡ãƒ¼ã‚¿å‡¦ç†
        if 'audio' in data_sources:
            audio_response = self.bedrock.invoke_model(
                modelId='amazon.nova-sonic-v1',
                body=data_sources['audio']
            )
            processed_data['transcription'] = json.loads(
                audio_response['body'].read()
            )['transcription']
      
        # ãƒ“ãƒ‡ã‚ªãƒ‡ãƒ¼ã‚¿å‡¦ç†
        if 'video' in data_sources:
            video_response = self.bedrock.invoke_model(
                modelId='amazon.nova-omni-v1',
                body=json.dumps({
                    "video": data_sources['video'],
                    "extractKeyFrames": True,
                    "analyzeActions": True
                })
            )
            processed_data['video_analysis'] = json.loads(
                video_response['body'].read()
            )
      
        # åŸ‹ã‚è¾¼ã¿ç”Ÿæˆï¼ˆæ¤œç´¢ç”¨ï¼‰
        if 'search_query' in data_sources:
            embedding_response = self.bedrock.invoke_model(
                modelId='amazon.nova-multimodal-embeddings-v1',
                body=json.dumps(data_sources['search_query'])
            )
            processed_data['embedding'] = json.loads(
                embedding_response['body'].read()
            )['embedding']
      
        return processed_data
  
    def agent_reasoning(self, processed_data, task_description):
        """Agentã§é«˜åº¦ãªæ¨è«–ã¨æ„æ€æ±ºå®š"""
        response = self.bedrock_agent.invoke_agent(
            agentId=self.agent_id,
            agentAliasId='PROD',
            sessionId=f"pipeline-{uuid.uuid4()}",
            inputText=json.dumps({
                "task": task_description,
                "processedData": processed_data
            })
        )
      
        result = ""
        for event in response['completion']:
            if 'chunk' in event:
                result += event['chunk']['bytes'].decode('utf-8')
      
        return json.loads(result)
  
    def execute_pipeline(self, data_sources, task):
        """å®Œå…¨ãªãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œ"""
        # ãƒ•ã‚§ãƒ¼ã‚º1: ãƒ‡ãƒ¼ã‚¿å‰å‡¦ç†
        print("ğŸ“Š Phase 1: Multimodal data preprocessing...")
        processed = self.preprocess_multimodal_data(data_sources)
      
        # ãƒ•ã‚§ãƒ¼ã‚º2: Agentæ¨è«–
        print("ğŸ¤– Phase 2: Agent reasoning...")
        result = self.agent_reasoning(processed, task)
      
        return result

# ä½¿ç”¨ä¾‹: åŒ»ç™‚è¨ºæ–­æ”¯æ´
pipeline = MultimodalPipeline(agent_id='medical-diagnosis-agent')

result = pipeline.execute_pipeline(
    data_sources={
        'video': patient_examination_video,
        'audio': doctor_notes_audio,
        'search_query': {
            'text': 'é¡ä¼¼ç—‡ä¾‹ã‚’æ¤œç´¢',
            'image': patient_xray_image
        }
    },
    task="æ‚£è€…ã®ç—‡çŠ¶ã‚’åˆ†æã—ã€é‘‘åˆ¥è¨ºæ–­ã¨æ¨å¥¨ã•ã‚Œã‚‹æ¤œæŸ»ã‚’æç¤ºã—ã¦ãã ã•ã„"
)

print(result)
```

### ãƒ‘ã‚¿ãƒ¼ãƒ³3: Multi-Agentå”èª¿å‹

**ç‰¹å¾´**: è¤‡æ•°ã®AgentãŒNovaãƒ¢ãƒ‡ãƒ«ã‚’æ´»ç”¨ã—ãªãŒã‚‰å”èª¿å‹•ä½œ

**å®Ÿè£…ä¾‹**:

```python
class MultiAgentSystem:
    def __init__(self):
        self.bedrock_agent = boto3.client('bedrock-agent-runtime')
      
        # å„å°‚é–€Agent
        self.agents = {
            'audio_specialist': 'AUDIO_AGENT_ID',
            'vision_specialist': 'VISION_AGENT_ID',
            'search_specialist': 'SEARCH_AGENT_ID',
            'coordinator': 'COORDINATOR_AGENT_ID'
        }
  
    def coordinate_analysis(self, multimodal_input):
        """ã‚³ãƒ¼ãƒ‡ã‚£ãƒãƒ¼ã‚¿ãƒ¼AgentãŒå…¨ä½“ã‚’çµ±æ‹¬"""
      
        # Step 1: ã‚³ãƒ¼ãƒ‡ã‚£ãƒãƒ¼ã‚¿ãƒ¼ãŒåˆ†æè¨ˆç”»ã‚’ç«‹æ¡ˆ
        plan_response = self.bedrock_agent.invoke_agent(
            agentId=self.agents['coordinator'],
            sessionId='coord-session',
            inputText=json.dumps({
                "task": "analyze_multimodal_input",
                "input_types": list(multimodal_input.keys()),
                "goal": "Comprehensive analysis and synthesis"
            })
        )
      
        analysis_plan = self.extract_response(plan_response)
      
        # Step 2: å„å°‚é–€Agentã‚’ä¸¦åˆ—å®Ÿè¡Œ
        results = {}
      
        if 'audio' in multimodal_input:
            audio_result = self.bedrock_agent.invoke_agent(
                agentId=self.agents['audio_specialist'],
                sessionId='audio-session',
                inputText=json.dumps({
                    "audioData": multimodal_input['audio'],
                    "analysisDepth": "detailed"
                })
            )
            results['audio_analysis'] = self.extract_response(audio_result)
      
        if 'video' in multimodal_input:
            vision_result = self.bedrock_agent.invoke_agent(
                agentId=self.agents['vision_specialist'],
                sessionId='vision-session',
                inputText=json.dumps({
                    "videoData": multimodal_input['video'],
                    "extractActions": True,
                    "detectAnomalies": True
                })
            )
            results['vision_analysis'] = self.extract_response(vision_result)
      
        # Step 3: æ¤œç´¢AgentãŒé–¢é€£æƒ…å ±ã‚’åé›†
        search_result = self.bedrock_agent.invoke_agent(
            agentId=self.agents['search_specialist'],
            sessionId='search-session',
            inputText=json.dumps({
                "preliminaryResults": results,
                "searchDepth": "comprehensive"
            })
        )
        results['related_information'] = self.extract_response(search_result)
      
        # Step 4: ã‚³ãƒ¼ãƒ‡ã‚£ãƒãƒ¼ã‚¿ãƒ¼ãŒçµ±åˆåˆ†æ
        final_response = self.bedrock_agent.invoke_agent(
            agentId=self.agents['coordinator'],
            sessionId='coord-session',
            inputText=json.dumps({
                "task": "synthesize_results",
                "specialist_results": results,
                "generate_recommendations": True
            })
        )
      
        return self.extract_response(final_response)
  
    def extract_response(self, agent_response):
        """Agentå¿œç­”ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’æŠ½å‡º"""
        result = ""
        for event in agent_response['completion']:
            if 'chunk' in event:
                result += event['chunk']['bytes'].decode('utf-8')
        return json.loads(result)

# ä½¿ç”¨ä¾‹
multi_agent = MultiAgentSystem()

comprehensive_result = multi_agent.coordinate_analysis({
    'audio': conference_call_recording,
    'video': presentation_slides_video,
    'documents': meeting_materials
})

print(json.dumps(comprehensive_result, ensure_ascii=False, indent=2))
```

## å®Ÿè£…æ™‚ã®ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

### 1. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ãƒªãƒˆãƒ©ã‚¤æˆ¦ç•¥

```python
import time
from botocore.exceptions import ClientError

def invoke_with_retry(client, model_id, body, max_retries=3):
    """ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½ä»˜ããƒ¢ãƒ‡ãƒ«å‘¼ã³å‡ºã—"""
    for attempt in range(max_retries):
        try:
            response = client.invoke_model(
                modelId=model_id,
                body=body
            )
            return response
      
        except ClientError as e:
            error_code = e.response['Error']['Code']
          
            if error_code == 'ThrottlingException':
                # æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•
                wait_time = (2 ** attempt) + random.uniform(0, 1)
                print(f"Rate limited. Waiting {wait_time:.2f}s...")
                time.sleep(wait_time)
          
            elif error_code == 'ModelTimeoutException':
                print(f"Model timeout. Attempt {attempt + 1}/{max_retries}")
                if attempt == max_retries - 1:
                    raise
          
            else:
                raise
  
    raise Exception(f"Failed after {max_retries} attempts")
```

### 2. ã‚³ã‚¹ãƒˆæœ€é©åŒ–

```python
class CostOptimizedProcessor:
    def __init__(self):
        self.cache = {}  # Embeddingã‚­ãƒ£ãƒƒã‚·ãƒ¥
        self.batch_queue = []  # ãƒãƒƒãƒå‡¦ç†ã‚­ãƒ¥ãƒ¼
  
    def get_embedding_cached(self, content, content_hash=None):
        """ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ©Ÿèƒ½ä»˜ãã‚¨ãƒ³ãƒ™ãƒ‡ã‚£ãƒ³ã‚°å–å¾—"""
        if content_hash is None:
            content_hash = hashlib.md5(content.encode()).hexdigest()
      
        if content_hash in self.cache:
            print("âœ… Cache hit")
            return self.cache[content_hash]
      
        # æ–°è¦ç”Ÿæˆ
        embedding = self.generate_embedding(content)
        self.cache[content_hash] = embedding
      
        return embedding
  
    def batch_process(self, items, batch_size=10):
        """ãƒãƒƒãƒå‡¦ç†ã§ã‚³ã‚¹ãƒˆå‰Šæ¸›"""
        results = []
      
        for i in range(0, len(items), batch_size):
            batch = items[i:i + batch_size]
          
            # ãƒãƒƒãƒãƒªã‚¯ã‚¨ã‚¹ãƒˆ
            batch_response = self.bedrock.invoke_model(
                modelId='amazon.nova-multimodal-embeddings-v1',
                body=json.dumps({
                    "inputs": batch,
                    "batchMode": True
                })
            )
          
            batch_results = json.loads(batch_response['body'].read())
            results.extend(batch_results['embeddings'])
      
        return results
```

### 3. ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ã¨ãƒ­ã‚®ãƒ³ã‚°

```python
import logging
from datetime import datetime

class MonitoredNovaClient:
    def __init__(self):
        self.bedrock = boto3.client('bedrock-runtime')
        self.cloudwatch = boto3.client('cloudwatch')
        self.logger = logging.getLogger('NovaClient')
  
    def invoke_model_monitored(self, model_id, body, operation_name):
        """ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†ä»˜ããƒ¢ãƒ‡ãƒ«å‘¼ã³å‡ºã—"""
        start_time = time.time()
      
        try:
            response = self.bedrock.invoke_model(
                modelId=model_id,
                body=body
            )
          
            latency = time.time() - start_time
          
            # CloudWatchãƒ¡ãƒˆãƒªã‚¯ã‚¹é€ä¿¡
            self.cloudwatch.put_metric_data(
                Namespace='BedrockNova',
                MetricData=[
                    {
                        'MetricName': 'InvocationLatency',
                        'Value': latency,
                        'Unit': 'Seconds',
                        'Dimensions': [
                            {'Name': 'ModelId', 'Value': model_id},
                            {'Name': 'Operation', 'Value': operation_name}
                        ]
                    },
                    {
                        'MetricName': 'InvocationSuccess',
                        'Value': 1,
                        'Unit': 'Count',
                        'Dimensions': [
                            {'Name': 'ModelId', 'Value': model_id}
                        ]
                    }
                ]
            )
          
            self.logger.info(f"âœ… {operation_name} completed in {latency:.2f}s")
            return response
          
        except Exception as e:
            # ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒˆãƒªã‚¯ã‚¹
            self.cloudwatch.put_metric_data(
                Namespace='BedrockNova',
                MetricData=[
                    {
                        'MetricName': 'InvocationError',
                        'Value': 1,
                        'Unit': 'Count',
                        'Dimensions': [
                            {'Name': 'ModelId', 'Value': model_id},
                            {'Name': 'ErrorType', 'Value': type(e).__name__}
                        ]
                    }
                ]
            )
          
            self.logger.error(f"âŒ {operation_name} failed: {str(e)}")
            raise
```

## ã¾ã¨ã‚

Amazon Bedrockã®Novaã‚·ãƒªãƒ¼ã‚ºã¯ã€éŸ³å£°å‡¦ç†ã‹ã‚‰ãƒãƒ«ãƒãƒ¢ãƒ¼ãƒ€ãƒ«ç†è§£ã€åŸ‹ã‚è¾¼ã¿è¡¨ç¾ã¾ã§ã€AIã®ä¸»è¦é ˜åŸŸã‚’ã‚«ãƒãƒ¼ã™ã‚‹åŒ…æ‹¬çš„ãªã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ã§ã™ã€‚Bedrock Agentsï¼ˆStrands Agentsã‚„Agent Coreï¼‰ã¨çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€ä»¥ä¸‹ã®ã‚ˆã†ãªé«˜åº¦ãªã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã§ãã¾ã™ï¼š

- **ã‚¨ãƒ³ã‚¿ãƒ¼ãƒ—ãƒ©ã‚¤ã‚ºAIã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³**: è¤‡æ•°ã®ãƒ¢ãƒ‡ãƒ«ã‚’çµ±åˆã—ãŸå®Ÿç”¨çš„ãªã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³
- **è‡ªå‹•åŒ–ã•ã‚ŒãŸãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼**: Agentã«ã‚ˆã‚‹ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã§è¤‡é›‘ãªå‡¦ç†ã‚’è‡ªå‹•åŒ–
- **ã‚¹ã‚±ãƒ¼ãƒ©ãƒ–ãƒ«ãªã‚·ã‚¹ãƒ†ãƒ **: AWSåŸºç›¤ã«ã‚ˆã‚‹å¤§è¦æ¨¡å±•é–‹

å„ãƒ¢ãƒ‡ãƒ«ã¨Agentsã®ç‰¹æ€§ã‚’ç†è§£ã—ã€é©åˆ‡ã«çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€å¾“æ¥ã§ã¯å›°é›£ã ã£ãŸè¤‡é›‘ãªAIå‡¦ç†ãŒå®Ÿç¾å¯èƒ½ã«ãªã‚Šã¾ã™ã€‚